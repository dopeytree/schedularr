import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField
} from "./chunk-TKZWA4SW.js";

// node_modules/emoji-blast/lib/range.js
var randomInRange = (range) => typeof range === "number" ? range : Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;

// node_modules/emoji-blast/lib/utils.js
var obtainValue = (value) => typeof value === "function" ? value() : value;
var randomArrayMember = (array) => {
  return array[Math.floor(Math.random() * array.length)];
};
var shuffleArray = (array) => {
  const copiedArray = array.slice();
  for (let i = copiedArray.length - 1; i > 0; i -= 1) {
    const swappingIndex = Math.floor(Math.random() * (i + 1));
    const swapper = copiedArray[i];
    copiedArray[i] = copiedArray[swappingIndex];
    copiedArray[swappingIndex] = swapper;
  }
  return copiedArray;
};

// node_modules/emoji-blast/lib/actor.js
var outOfBounds = 350;
var _opacity, _physics, _position, _velocity;
var EmojiActor = class {
  constructor(settings) {
    /**
     * CSS opacity style, starting at 1 for fully visible.
     */
    __privateAdd(this, _opacity, 1);
    /**
     * Runtime change constants for actor movements.
     */
    __privateAdd(this, _physics);
    /**
     * Current element coordinates and rotation.
     */
    __privateAdd(this, _position);
    /**
     * Change amounts for element position.
     */
    __privateAdd(this, _velocity);
    /**
     * Attached element kept in the DOM.
     */
    __publicField(this, "element");
    var _a;
    this.element = document.createElement("button");
    this.element.className = settings.className;
    this.element.textContent = randomArrayMember(settings.emojis);
    this.element.setAttribute("role", "img");
    this.element.style.fontSize = `${randomInRange(settings.physics.fontSize)}px`;
    this.element.style.transition = "16ms opacity, 16ms transform";
    __privateSet(this, _physics, settings.physics);
    __privateSet(this, _position, {
      rotation: randomInRange(settings.physics.rotation),
      x: settings.position.x,
      y: settings.position.y
    });
    __privateSet(this, _velocity, {
      rotation: randomInRange(settings.physics.initialVelocities.rotation),
      x: randomInRange(settings.physics.initialVelocities.x),
      y: randomInRange(settings.physics.initialVelocities.y)
    });
    this.updateElement();
    (_a = settings.process) == null ? void 0 : _a.call(settings, this.element);
    settings.container.appendChild(this.element);
  }
  /**
   * Updates the attached DOM element to match tracking position.
   */
  updateElement() {
    this.element.style.opacity = `${__privateGet(this, _opacity)}`;
    this.element.style.transform = `translate(${__privateGet(this, _position).x}px, ${__privateGet(this, _position).y}px) rotate(${Math.round(__privateGet(this, _position).rotation)}deg)`;
  }
  /**
   * Moves the actor forward one tick.
   * @param timeElapsed   How many milliseconds have passed since the last action.
   * @returns Whether this is now dead.
   */
  act(timeElapsed) {
    if (__privateGet(this, _physics).opacityDecay) {
      __privateSet(this, _opacity, __privateGet(this, _opacity) - timeElapsed / (__privateGet(this, _physics).opacityDecay * __privateGet(this, _physics).framerate));
      if (__privateGet(this, _opacity) <= 0) {
        return true;
      }
    }
    __privateGet(this, _velocity).rotation *= __privateGet(this, _physics).rotationDeceleration;
    __privateGet(this, _velocity).y += __privateGet(this, _physics).gravity;
    __privateGet(this, _position).rotation += __privateGet(this, _velocity).rotation;
    __privateGet(this, _position).x += __privateGet(this, _velocity).x * timeElapsed / __privateGet(this, _physics).framerate;
    __privateGet(this, _position).y += __privateGet(this, _velocity).y * timeElapsed / __privateGet(this, _physics).framerate;
    const windowHeight = window.outerHeight || document.documentElement.clientHeight;
    const windowWidth = window.outerWidth || document.documentElement.clientWidth;
    if (!__privateGet(this, _physics).preserveOutOfBounds) {
      if (__privateGet(this, _position).y - this.element.clientHeight > windowHeight + outOfBounds) {
        return true;
      }
      if (__privateGet(this, _position).y + this.element.clientHeight < -outOfBounds) {
        return true;
      }
      if (__privateGet(this, _position).x - this.element.clientWidth > windowWidth + outOfBounds) {
        return true;
      }
      if (__privateGet(this, _position).x + this.element.clientWidth < -outOfBounds) {
        return true;
      }
    }
    this.updateElement();
    return false;
  }
  /**
   * Disposes of the attached DOM element upon actor death.
   */
  dispose() {
    if (this.element.parentElement !== null) {
      this.element.parentElement.removeChild(this.element);
    }
  }
  /**
   * Updates the emoji for being clicked.
   */
  update(updates) {
    if (updates.opacity !== void 0) {
      __privateSet(this, _opacity, updates.opacity);
    }
    if (updates.velocity !== void 0) {
      if (updates.velocity.rotation !== void 0) {
        __privateGet(this, _velocity).rotation = updates.velocity.rotation;
      }
      if (updates.velocity.x !== void 0) {
        __privateGet(this, _velocity).x = updates.velocity.x;
      }
      if (updates.velocity.y !== void 0) {
        __privateGet(this, _velocity).y = updates.velocity.y;
      }
    }
  }
  /**
   * CSS opacity style, starting at 1 for fully visible.
   */
  get opacity() {
    return __privateGet(this, _opacity);
  }
  /**
   * Current element coordinates and rotation.
   */
  get position() {
    return __privateGet(this, _position);
  }
  /**
   * Change amounts for element position.
   */
  get velocity() {
    return __privateGet(this, _velocity);
  }
};
_opacity = new WeakMap();
_physics = new WeakMap();
_position = new WeakMap();
_velocity = new WeakMap();

// node_modules/emoji-blast/lib/animate.js
function animate(actors, beforeTick) {
  let timeStart = performance.now();
  let stopped = false;
  const stop = () => {
    stopped = true;
  };
  beforeTick == null ? void 0 : beforeTick(actors);
  if (stopped) {
    return { stop };
  }
  const runTick = (timeCurrent) => {
    if (stopped) {
      return;
    }
    beforeTick == null ? void 0 : beforeTick(actors);
    if (actors.length === 0) {
      return;
    }
    const timeElapsed = timeCurrent - timeStart;
    for (let i = 0; i < actors.length; i += 1) {
      const actor = actors[i];
      if (actor.act(timeElapsed)) {
        actor.dispose();
        actors.splice(i, 1);
        i -= 1;
        continue;
      }
    }
    if (actors.length === 0) {
      return;
    }
    timeStart = timeCurrent;
    if (!stopped) {
      requestAnimationFrame(runTick);
    }
  };
  requestAnimationFrame(runTick);
  return { stop };
}

// node_modules/emoji-blast/lib/emojis.js
var defaultEmojis = [
  "ðŸ˜",
  "ðŸ˜‚",
  "ðŸ¤£",
  "ðŸ˜ƒ",
  "ðŸ˜†",
  "ðŸ˜",
  "ðŸ¤©",
  "ðŸ˜Ž",
  "ðŸ¤—",
  "ðŸ¥³",
  "ðŸ¤–",
  "ðŸ˜»",
  "ðŸ˜¹",
  "ðŸ±",
  "ðŸ¶",
  "ðŸ™ˆ",
  "ðŸ™‰",
  "ðŸ™Š",
  "ðŸ„",
  "ðŸ’ª",
  "ðŸ‘Œ",
  "ðŸ‘‹",
  "ðŸ™Œ",
  "ðŸ«¶",
  "ðŸ’",
  "ðŸ’–",
  "ðŸ’—",
  "ðŸ§¡",
  "ðŸ’›",
  "ðŸ’š",
  "ðŸ’™",
  "ðŸ’œ",
  "â¤ï¸â€ðŸ”¥",
  "ðŸ”¥",
  "ðŸš€",
  "â›„",
  "ðŸ¦©",
  "ðŸ",
  "ðŸ’",
  "ðŸ¦¾",
  "âœ¨",
  "ðŸŽ‰",
  "ðŸ’¯"
];

// node_modules/emoji-blast/lib/events.js
var attributeIndicator = "data-emoji-blast-events-initialized";
var domNodesToActors = /* @__PURE__ */ new WeakMap();
function initializeEvents(actors, container, events) {
  for (const actor of actors) {
    domNodesToActors.set(actor.element, actor);
  }
  if (container.hasAttribute(attributeIndicator)) {
    return;
  }
  container.setAttribute(attributeIndicator, "true");
  container.addEventListener("click", (event) => {
    const actor = event.target && domNodesToActors.get(event.target);
    if (actor) {
      events.onClick({ actor, event });
    }
  });
}

// node_modules/emoji-blast/lib/styles.js
var createdStyles = /* @__PURE__ */ new Set();
var createStyleElementAndClass = (className) => {
  if (createdStyles.has(className)) {
    return;
  }
  createdStyles.add(className);
  const element = document.createElement("style");
  element.setAttribute("type", "text/css");
  element.appendChild(document.createTextNode(`
		.${className} {
			background: none;
			border: none;
			cursor: default;
			height: 2em;
			margin-left: -1em;
			margin-top: -1em;
			position: fixed;
			user-select: none;
			width: 2em;
			z-index: 2147483647;
		}
	`));
  document.head.appendChild(element);
};

// node_modules/emoji-blast/lib/emojiBlast.js
var defaultClassName = "emoji-styles";
var defaultCreateContainer = /* @__PURE__ */ (() => {
  let container;
  return () => {
    if ((container == null ? void 0 : container.parentNode) === document.body) {
      return container;
    }
    container = document.createElement("div");
    document.body.prepend(container);
    return container;
  };
})();
var defaultEmojiCount = () => Math.floor(Math.random() * 14) + 14;
var defaultEvents = {
  onClick({ actor }) {
    actor.update({
      opacity: 1,
      velocity: {
        y: actor.velocity.y / 2 - 15
      }
    });
  }
};
var defaultPhysics = {
  fontSize: {
    max: 28,
    min: 14
  },
  framerate: 60,
  gravity: 0.35,
  initialVelocities: {
    rotation: {
      max: 7,
      min: -7
    },
    x: {
      max: 7,
      min: -7
    },
    y: {
      max: -7,
      min: -21
    }
  },
  preserveOutOfBounds: false,
  rotation: {
    max: 45,
    min: -45
  },
  rotationDeceleration: 0.98
};
var defaultPosition = () => ({
  x: Math.random() * innerWidth,
  y: Math.random() * innerHeight
});
var emojiBlast = (settings = {}) => {
  const { className = defaultClassName, container: containerSetting = defaultCreateContainer, emojiCount = defaultEmojiCount, emojis = defaultEmojis, events = defaultEvents, position = defaultPosition, process, tick, uniqueness = Infinity } = settings;
  const container = obtainValue(containerSetting);
  createStyleElementAndClass(className);
  const physics = {
    ...defaultPhysics,
    ...settings.physics,
    initialVelocities: {
      ...defaultPhysics.initialVelocities,
      ...settings.physics !== void 0 ? settings.physics.initialVelocities : {}
    }
  };
  const emojiSettings = {
    className,
    container,
    // Copy the input array to prevent modifications.
    emojis: shuffleArray(obtainValue(emojis)).slice(0, obtainValue(uniqueness)),
    physics,
    position: obtainValue(position),
    process
  };
  const blastEmojiCount = obtainValue(emojiCount);
  const actors = [];
  for (let i = 0; i < blastEmojiCount; i += 1) {
    actors.push(new EmojiActor(emojiSettings));
  }
  initializeEvents(actors, container, events);
  return animate(actors, tick);
};

// node_modules/emoji-blast/lib/emojiBlasts.js
var defaultInterval = () => 700 + Math.floor(Math.random() * 1401);
var emojiBlasts = (settings = {}) => {
  const { interval = defaultInterval, scheduler = setTimeout } = settings;
  let cancelled = false;
  const blast = () => {
    emojiBlast(settings);
  };
  const blastAndSchedule = () => {
    if (cancelled) {
      return;
    }
    if (document.visibilityState === "visible") {
      blast();
    }
    scheduler(blastAndSchedule, obtainValue(interval));
  };
  scheduler(blastAndSchedule, 0);
  return {
    blast,
    cancel() {
      cancelled = true;
    }
  };
};
export {
  EmojiActor,
  defaultClassName,
  defaultCreateContainer,
  defaultEmojiCount,
  defaultEmojis,
  defaultEvents,
  defaultPhysics,
  defaultPosition,
  emojiBlast,
  emojiBlasts
};
//# sourceMappingURL=emoji-blast.js.map
